---
layout: post
published: false
title: jhm.adoc
---
== JHM - Benchmark java tool 

"JMH is a Java harness for building, running, and analysing nano/micro/milli/macro 
benchmarks written in Java and other languages targetting the JVM."
footnote:[http://openjdk.java.net/projects/code-tools/jmh/]

=== Basic considerations

1. Run with http://maven.apache.org[Maven].
2. Create a new standalone project based on the maven archetype.

=== Example

- Create the standaole project based on the maven archetype.

[source, bash]
mvn archetype:generate \
          -DinteractiveMode=false \
          -DarchetypeGroupId=org.openjdk.jmh \
          -DarchetypeArtifactId=jmh-java-benchmark-archetype \
          -DgroupId=com.backbase \
          -DartifactId=benchmarks \
          -Dversion=1.20

- Create the escenario to benchmark, in this case let work with factorial
example as is in below class. 

[source, java]
----
public class Factorial {

    public static int getFactorialFor(int number) {
        int factorial = 1;
        for (int i = 2; i <= number; i++) {
            factorial *= i;
        }
        return factorial;
    }

    public static int getFactorialRec(int number) {
        if (number == 0) {
            return 1;
        } else {
            return number * getFactorialRec(number - 1);
        }
    }

}
----

- Create a new Class in with the benchmark will be added. Below 

[source, java]
----
    private static final int SMALL_NUMBER = 4;
    private static final int LONG_NUMBER = 30;

    @Benchmark
    @BenchmarkMode(Mode.AverageTime)
    @OutputTimeUnit(TimeUnit.MICROSECONDS)
    public int testFactorialWithLoopForWithSmallNumber() {
        return Factorial.getFactorialFor(SMALL_NUMBER);
    }

    @Benchmark
    @BenchmarkMode(Mode.AverageTime)
    @OutputTimeUnit(TimeUnit.MICROSECONDS)
    public int testFactorialWithRecursiveMethodWithSmallNumber() {
        return Factorial.getFactorialRec(SMALL_NUMBER);
    }

    @Benchmark
    @BenchmarkMode(Mode.AverageTime)
    @OutputTimeUnit(TimeUnit.MICROSECONDS)
    public int testFactorialWithLoopForWithLongNumber() {
        return Factorial.getFactorialFor(LONG_NUMBER);
    }

    @Benchmark
    @BenchmarkMode(Mode.AverageTime)
    @OutputTimeUnit(TimeUnit.MICROSECONDS)
    public int testFactorialWithRecursiveMethodWithLongNumber() {
        return Factorial.getFactorialRec(LONG_NUMBER);
    }
----

- Run the benchmark

[source, bash]
mvn clean package
java -jar target/benchmarks.jar

- Get the results

[source, bash]
----
Result "com.backbase.BenchmarkFactorial.testFactorialWithRecursiveMethodWithSmallNumber":
  0.006 ±(99.9%) 0.001 us/op [Average]
  (min, avg, max) = (0.006, 0.006, 0.012), stdev = 0.001
  CI (99.9%): [0.006, 0.006] (assumes normal distribution)


# Run complete. Total time: 00:26:58

Benchmark                                                           Mode  Cnt  Score    Error  Units
BenchmarkFactorial.testFactorialWithLoopForWithLongNumber           avgt  200  0.002 ±  0.001  us/op
BenchmarkFactorial.testFactorialWithLoopForWithSmallNumber          avgt  200  0.002 ±  0.001  us/op
BenchmarkFactorial.testFactorialWithRecursiveMethodWithLongNumber   avgt  200  0.043 ±  0.001  us/op
BenchmarkFactorial.testFactorialWithRecursiveMethodWithSmallNumber  avgt  200  0.006 ±  0.001  us/op
----

In above result we can see how is better to use the `for` based method instead of 
`recursive` method to calculate the factorial.

=== Some configurations to take into account.

==== Benchmark modes

|===
|Throughput	| Measures the number of operations per second, meaning the number of times per second your benchmark method could be executed.
|Average Time	| Measures the average time it takes for the benchmark method to execute (a single execution).
|Sample Time	| Measures how long time it takes for the benchmark method to execute, including max, min time etc.
|Single Shot Time	| Measures how long time a single benchmark method execution takes to run. This is good to test how it performs under a cold start (no JVM warm up).
|All |	Measures all of the above.
|===

By default benchmark mode is Throughput.

To specify the mode a benchmark will run, use the annotation @Benchmark above the 
method to affect.

[source, java]
@BenchmarkMode(Mode.AverageTime)
public int testFactorialWithLoopForWithSmallNumber() {

==== Benchmark time units

The posible time units come from `java.util.concurrent.TimeUnit`, below the table with
the posbile values.

|===
| NANOSECONDS
| MICROSECONDS
| MILLISECONDS
| SECONDS
| MINUTES
| HOURS
| DAYS
|===

The time unit is specified with the annotation `@OutputTimeUnit`, and it is put it
at `@Benchmark` method to have effect in that method only, or at the enclosing class
instance to have effect over all `@Benchmark` methods in the class. e.g.

[source, java]
@OutputTimeUnit(TimeUnit.MICROSECONDS)
public int testFactorialWithLoopForWithSmallNumber() {

[#state-scope]
=== State scope

In most of the cases, values initialization will be needed. As JHM allow us to run 
benchmark in different threads it give us the `@State` to specify the how the state
will be shared. This state should be declared in a class inside the benchmark class
and annoted with `@State` annotation specifing how this state class will be shared.
Below the option availables

|===
|Thread|	Each thread running the benchmark will create its own instance of the state object.
|Group	|Each thread group running the benchmark will create its own instance of the state object.
|Benchmark	|All threads running the benchmark share the same state object.
|===

e.g.

[source, java]
----
public class MyBenchmark {

    @State(Scope.Thread)
    public static class MyState {
        public int a = 1;
        public int b = 2;
        public int sum ;
    }


    @Benchmark @BenchmarkMode(Mode.Throughput) @OutputTimeUnit(TimeUnit.MINUTES)
    public void testMethod(MyState state) {
        state.sum = state.a + state.b;
    }

}
----

In example above each thread will have its own instance of `MyState` class which 
will be given as a parameter in the methos `testMethod`.

=== Consideration to write benchmarks

The JVM does some code improvements in order to have a better performance in the 
code, but specially 2 could affect the result of a benchmark is this is not 
correctly write.

==== Dead code elimination

When a result of a benchmark is not used the JVM will avoid run the code get this 
result, below lets see an example about how is a code wrongly wrote and two strategies
to fix it.

__Wrong benchmark__:

Below snipped shows a classic example the how the dead code elimination works. In this
case the JVM notices that the variable sum is never used so it eliminates this fragment
in compilation time getting us a wrong benchmark result.

[source, java]
----
@Benchmark
public void testMethod() {
    int a = 1;
    int b = 2;
    int sum = a + b;
}
----

__Fixing returning the value__:

One strategy to avoid the dead code elimination is returning the value in the 
`@Benchmark` mehod.

[source, java]
----
@Benchmark
public void testMethod() {
    int a = 1;
    int b = 2;
    int sum = a + b;
    return sum;
}
----

__Fixing with Blackhole class__:

Other way to deal with the dead code elimination is using the 
`org.openjdk.jmh.infra.Blackhole` class provided by JHM library. In this case the
`@Benchmark` method should receive this instance as a parameter and perform a 
`Blackhole.consume` call sending the result instead of return it

[source, java]
----
@Benchmark
public void testMethod(Blackhole bh) {
    int a = 1;
    int b = 2;
    int sum = a + b;
    bh.consume( sum );
}
----

==== Constant folding

Other JVM code optimization is Constant Folding, in this case the JVM checks the code 
and if founds a code with a calculation based on constants this calculation will often
result in the exact same result, for this reson replace the code with the constant 
instead of do the calculation.

[source, java]
int a = 1;
int b = 2;
int sum = a + b;
return sum

The avobe code will be replaced with this:

[source, java]
return 3;

To avoid the Constant Folding should be used try to not use hardcoded constants 
inside the method, instead of this, use link:#state-scope[States].

[source, java]
@Benchmark 
public int testMethod(MyState state) {
    int sum = state.a + state.b;
    return sum;
}


NOTE: For more information check the official http://openjdk.java.net/projects/code-tools/jmh/[documentation]